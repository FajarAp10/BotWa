
if (text.toLowerCase().startsWith('.brat')) {
    const userText = text.replace('.brat', '').trim();
    if (!userText) {
        await sock.sendMessage(from, {
            text: '‚ùå Contoh: *.brat kamu kemana*'
        }, { quoted: msg });
        return;
    }

    await sock.sendMessage(from, { react: { text: '‚è≥', key: msg.key } });

    const isBypass = isOwner(sender) || isVIP(sender, from);
    const now = Date.now();
    const aksesBrat = bratAksesSementara.get(sender);
    const isTemporaryActive = aksesBrat && now < aksesBrat;

    // VIP dan Owner bebas limit
if (!(isOwner(sender) || isVIP(sender, from) || isTemporaryActive)) {
    const record = bratLimit.get(sender);
    if (record) {
        if (now - record.time < BRAT_COOLDOWN) {
            if (record.count >= MAX_BRAT) {
                const sisa = Math.ceil((BRAT_COOLDOWN - (now - record.time)) / 60000);
                await sock.sendMessage(from, {
                   text: `üö´ *Limit Tercapai*\n\nKamu hanya bisa memakai *.brat* 3x per jam.\n‚è≥ Tunggu *${sisa} menit* lagi atau beli akses *.belibrat* 30 menit.\n\nüí° *Tips:* Beli akses *VIP* agar bisa memakai *.brat* tanpa batas waktu.`,

                    mentions: [sender]
                }, { quoted: msg });
                return;
            } else record.count++;
        } else {
            bratLimit.set(sender, { count: 1, time: now });
        }
    } else {
        bratLimit.set(sender, { count: 1, time: now });
    }
}


    try {
        const width = 512;
        const height = 512;
        const maxLineWidth = 470;
        let fontSize = 130;

        const words = userText.split(/\s+/);
        const estimateWordWidth = (word, size) => word.length * size * 0.6;

        function generateLines(size) {
            const result = [[]];
            let currentLineWidth = 0;
            for (let word of words) {
                const wordWidth = estimateWordWidth(word, size);
                if (currentLineWidth + wordWidth > maxLineWidth && result[result.length - 1].length > 0) {
                    result.push([word]);
                    currentLineWidth = wordWidth;
                } else {
                    result[result.length - 1].push(word);
                    currentLineWidth += wordWidth + 25 + Math.random() * 15;
                }
            }
            return result;
        }

        function isOverflow(lines, size) {
            const lineHeight = size + 20;
            if (lines.length * lineHeight > 480) return true;
            for (const line of lines) {
                let lineWidth = 0;
                for (const word of line) {
                    lineWidth += estimateWordWidth(word, size) + 25 + Math.random() * 15;
                }
                if (lineWidth > maxLineWidth) return true;
            }
            return false;
        }

        let lines = [];
        let tryFont = fontSize;

        while (tryFont >= 60) {
            const candidateLines = generateLines(tryFont);
            if (!isOverflow(candidateLines, tryFont)) {
                lines = candidateLines;
                fontSize = tryFont;
                break;
            }
            if (candidateLines.length <= 2 && words.length >= 6) tryFont -= 2;
            else tryFont -= 4;
        }

        if (lines.length === 0) {
            fontSize = 60;
            lines = generateLines(fontSize);
        }

        const lineHeight = fontSize + 20;
        const totalHeight = lines.length * lineHeight;
        const verticalBias = Math.floor((height - totalHeight) / 2 + fontSize * 0.40 + lines.length * 5);
        let y = verticalBias + 8; // buffer biar huruf gak nempel atas

        let svgText = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
  <rect width="100%" height="100%" fill="white"/>
  <style>
  .brat {
    font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', Arial, Helvetica, sans-serif;
    fill: black;
    font-size: ${fontSize}px;
  }
</style>\n`;

        for (const line of lines) {
            let x = 30;
            for (let word of line) {
                const yOffset = y + Math.floor(Math.random() * 6 - 3);
                svgText += `<text x="${x}" y="${yOffset}" class="brat">${word}</text>\n`;
                const wordWidth = estimateWordWidth(word, fontSize);
                x += wordWidth + 25 + Math.random() * 10;
            }
            y += lineHeight + Math.floor(Math.random() * 10);
        }

        svgText += `</svg>`;

        const buffer = await sharp({
            create: {
                width,
                height,
                channels: 4,
                background: 'white'
            }
        })
        .composite([{ input: Buffer.from(svgText), top: 0, left: 0 }])
        .webp()
        .toBuffer();

        const sticker = new Sticker(buffer, {
            type: 'FULL',
            pack: 'brat-anomali',
            author: 'Jarr',
            quality: 100
        });

        await sock.sendMessage(from, await sticker.toMessage(), { quoted: msg });
        await sock.sendMessage(from, { react: { text: '‚úÖ', key: msg.key } });

    } catch (err) {
        console.error(err);
        await sock.sendMessage(from, {
            text: '‚ùå Gagal membuat stiker brat.'
        }, { quoted: msg });
    }
}
